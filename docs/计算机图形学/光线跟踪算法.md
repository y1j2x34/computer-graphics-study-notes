# 光线算法

## 光线跟踪概述

可以实现其它算法来很难达到的效果，它作为一个有效的真实感图形绘制算法被管范地使用。

为什么我们能看见物体：

光(Light) 可以理解为一系列由光源发出、经物体反复弹射而最终进入视点的光线(Rays)，最终将光线射入人们眼中，使我们看到物体。

### 光线跟踪的思路和框架

将显示缓存区看成是由空间中的像素组成的矩形阵列，人眼透过这些像素看到场景中的物体。对于每个像素 P 计算其色彩值：

- 计算由视点连接像素 P 中信的光线延长后所碰到的第一个物体的焦点
- 使用局部关照模型（如 Phong 模型）计算焦点处的颜色值
- 沿焦点处的反射和折射方向对光线进行跟踪

#### 光线跟踪的特征

通过光线跟踪，可以很容易地表现出例如阴影、反射、折射等引人入胜的视觉效果
除了基本的几何形体（例如球体、椎体、立方体等），光线跟踪容易适用于更复杂的物体表示方法（例如多边形网格表示或者复合形体等）。

#### 使用递归实现的光线跟踪算法

![使用递归实现的光线跟踪算法](../../assets/使用递归实现的光线跟踪算法.png)

```txt
IntersectColor(vBeginPoint, vDirection) {
    Determine IntersectPoint; 
    Color = ambient color; // 环境光
    for each light 
        Colo += local shading term;
    if(surface is reflective) // 判断表面是否可反射
        color += reflect Coefficient * IntersectColor(IntersectPoint, Reflect Ray); // 加上反射系数 * .... 
    else if (surface is refractive) 
        color += refract Coefficient * IntersectColor(IntersecPoint, Refract Ray); // 折射系数 * ....
    return color;
}
```

## 光线求交（Ray Intersection）

## 阴影（Shadows）

## 透明和镜面反射（Transparence and Specular Reflection）

## 纹理（textures）
